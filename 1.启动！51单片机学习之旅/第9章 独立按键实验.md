# 第九章 独立按键实验

## 1. 按键介绍

    按键是一种电子开关，当按下时开关接通，松开手开关断开。开发板上使用的按键及内部简易图如下图所示：

![](https://img.picgo.net/2024/06/01/-2024-06-01-1339227d23dc5d396c35de.png)

    通常的按键所用开关为机械弹性开关,当机械触点断开、 闭合时， 电压信号如下图所示：

![](https://ts1.cn.mm.bing.net/th/id/R-C.acdd3224c55703fcfb9bd61a2e00cd2c?rik=hKu1Ly23X4hAqQ&riu=http%3a%2f%2fwww.stepfpga.com%2fdoc%2f_media%2f%e6%8a%96%e5%8a%a8%e5%8e%9f%e7%90%86.png&ehk=7TajdgKxdl7Q3PizAoy9fkJEb2wyniCKr4fzrMdAiDY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1)

    由于机械按键的弹性作用，按键开关会有抖动误差，一般为5ms到10ms。为了确保CPU对按键的一次闭合仅做一次处理，必须进行消抖。

    按键消抖有两种方式， 一种是硬件消抖， 另一种是软件消抖。 为了使电路更加简单， 通常采用软件消抖。 我们开发板也是采用软件消抖， 一般来说一个简单的按键消抖就是先读取按键的状态， 如果得到按键按下之后， 延时 10ms， 再次读取按键的状态， 如果按键还是按下状态， 那么说明按键已经按下。 其中延时10ms 就是软件消抖处理。

    关于按键更多可以参考：[按钮开关_百度百科 (baidu.com)](https://baike.baidu.com/item/%E6%8C%89%E9%92%AE%E5%BC%80%E5%85%B3/8063907)

    关于消抖可以参考：[【单片机】按键消抖及原理（硬件和软件方法详解）-CSDN博客](https://blog.csdn.net/yechongbinbin/article/details/114821661)

## 2. 硬件设计

该实验用到的硬件资源如下：

- LED模块中的D1灯

- K1按键

    LED模块电路我们已经介绍过了，接下来我们看一下开发板上面的独立按键模块：

![](https://img.picgo.net/2024/06/01/-2024-06-01-135806c0dcaaad133c1e53.png)

    可以看到该模块独立，8个独立按键的控制管脚连接到JP1端子上

    如果要想 51 单片机能够检测按键是否按下， 就必须将单片机管脚通过导线连接到 JP1 端子上。 因此需使用一根 8Pin 排线将单片机的管脚与 JP1 端子顺序连接。 由于独立按键模块电路是独立的， 所以使用任意单片机管脚都可以。

    本次我们使用P3.0口来检测K1按键，使用P2.0控制D1指示灯

## 3. 软件设计

本次我们要实现的功能是：通过K1来控制D1指示灯亮灭

```c
#include <REGX52.H>

//定义K1按键控制脚
sbit KEY1 = P3^0;

//定义LED1控制脚
sbit LED1 = P2^0;

// 延时函数
void delay_us(unsigned int ten_us)
{
	while(ten_us--);	
}

int main()
{
	while(1)
	{
		if(KEY1 == 0) // 检测端口是否为低电平-开关按下
		{
			delay_us(20); // 消抖
			LED1 = !LED1; // 模拟灯的亮灭
		}
	}
}
```

    在51系列单片机中，通常使用的是“短接地”方式来检测按键是否按下。这意味着按键未被按下时，其对应的引脚处于高电平状态（1），而按下按键后，引脚会被接地，即处于低电平状态（0）。

## 4. 小结

    本节相比于上一节还容易，主要是认识了开关和按键消抖的必要性以及怎么消抖，代码很简单，用K1来控制翻转LED状态，按一下就翻转一下。这个代码是我改良了的，本来还有扫描按键的函数，但是我没有加上去，后面我们会遇到的。
