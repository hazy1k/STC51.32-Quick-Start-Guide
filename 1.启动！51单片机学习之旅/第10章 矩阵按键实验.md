# 第十章 矩阵按键实验

## 1. 矩阵按键介绍

    通过上一章我们知道了：独立按键在于单片机连接的时候，每一个按键都需要单片机的一个I/O口，若某单片机系统需较多按键， 如果用独立按键便会占用过多的 I/O 口资源。 单片机系统中 I/O 口资源往往比较宝贵， 当用到多个按键时为了减少 I/O 口引脚， 引入了矩阵按键。

    本章以 4*4 矩阵键盘为例讲解其工作原理和检测方法。开发板上将 16 个按键排成 4 行 4 列， 第一行将每个按键的一端连接在一起构成行线， 第一列将每个按键的另一端连接在一起构成列线， 这样便一共有 4 行 4 列共 8 根线， 我们将这 8 根线连接到单片机的 8 个 I/O 口上， 通过程序扫描键盘就可检测 16 个键。

    无论是对立按键还是矩阵键盘，检测是否按下都是一样的（检测该端口是否为低电平）

    关于矩阵按键更多参考：[矩阵键盘_百度百科 (baidu.com)](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/6008164)

    独立键盘有一端固定为低电平， 此种方式编程比较简单。 而矩阵键盘两端都与单片机 I/O 口相连， 因此在检测时需编程通过单片机 I/O 口送出低电平。 检测方法有多种， 最常用的是行列扫描和线翻转法。

- 行列扫描法：先给一列为低电平，其余列为高电平，然后立即检测一次各行是否为低电平，若检测到某一行为低电平，   则我们便可确认当前被按下的键是哪一行哪一列的。参考：[51单片机 | 矩阵键盘行扫描 - hugh.dong - 博客园 (cnblogs.com)](https://www.cnblogs.com/hughdong/p/6879891.html)

- 线翻转法：使所有的行线为低电平，检测所有列线是否有低电平，如果有， 就记录列线值； 然后再翻转， 使所有列线都为低电平， 检测所有行线的值，由于有按键按下， 行线的值也会有变化， 记录行线的值。 从而就可以检测到全部按键。参考：[单片机外设矩阵键盘之线反转法识别原理与示例 - IT宝库 (itbaoku.cn)](https://www.itbaoku.cn/post/3208930.html)

    本章我们使用行列扫描法

## 2. 硬件设计

本实验使用到硬件资源如下：

- 静态数码管

- 矩阵按键

    静态数码管模块我们已经介绍过了，请看矩阵按键模块：

![](https://img.picgo.net/2024/06/03/-2024-06-03-15041198c1fb1f36b1c3ac.png)

    我们可以看到该模块独立，4*4 矩阵按键引出的 8 根控制管脚并未直接连接到 51 单片机的 IO 上， 而是连接到 JP3 端子上。Hx（1~4）代表的是行，Lx（1~4）代表的是列。

    参考代码使用 P1 口来检测 4*4 矩阵按键， 使用 P0 口控制静态数码管。 单片机的 P17 口连接矩阵键盘的第 1 行， P13 口连接矩阵键盘第 1列。

## 3. 软件设计

    本章我们要实现的功能是：通过数码管显示矩阵按键S1~S16按下后显示0-F

```c
#include <REGX52.H>

//共阴极段码数据
unsigned char gsmg_code[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
				0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};	

void delay_us(unsigned int ten_us)
{
	while(ten_us--);	
}


int key_scan()
{
	unsigned int key_value;

	P1 = 0xf7; // 给第一列赋值0，其余全为1
	if(P1 != 0xf7) // 判断第一列按键是否按下
	{
		delay_us(1000);//消抖
		switch(P1) // 保存第一列按键按下后的键值	
		{
			case 0x77: 
				key_value = 1;
				break;
			case 0xb7: 
				key_value=5;
				break;
			case 0xd7: 
				key_value=9;
				break;
			case 0xe7: 
				key_value=13;
				break;
		}
	}
	while(P1 != 0xf7); // 等待按键松开	
	
	P1 = 0xfb;//给第二列赋值0，其余全为1
	if(P1 != 0xfb)//判断第二列按键是否按下
	{
		delay_us(1000);//消抖
		switch(P1)//保存第二列按键按下后的键值	
		{
			case 0x7b: 
				key_value=2;
				break;
			case 0xbb: 
				key_value=6;
				break;
			case 0xdb: 
				key_value=10;
				break;
			case 0xeb: 
				key_value=14;
				break;
		}
	}
	while(P1 != 0xfb);//等待按键松开	
	
	P1 = 0xfd; // 给第三列赋值0，其余全为1
	if(P1 != 0xfd) // 判断第三列按键是否按下
	{
		delay_us(1000); // 消抖
		switch(P1) // 保存第三列按键按下后的键值	
		{
			case 0x7d: 
				key_value=3;
				break;
			case 0xbd: 
				key_value=7;
				break;
			case 0xdd: 
				key_value=11;
				break;
			case 0xed: 
				key_value=15;
				break;
		}
	}
	while(P1 != 0xfd);//等待按键松开	
	
	P1 = 0xfe;//给第四列赋值0，其余全为1
	if(P1 != 0xfe)//判断第四列按键是否按下
	{
		delay_us(1000);//消抖
		switch(P1)//保存第四列按键按下后的键值	
		{
			case 0x7e: 
				key_value=4;
				break;
			case 0xbe: 
				key_value=8;
				break;
			case 0xde: 
				key_value=12;
				break;
			case 0xee: 
				key_value=16;
				break;
		}
	}
	while(P1 != 0xfe);//等待按键松开
	
	return key_value;		
}

void main()
{	
	int key;

	while(1)
	{
	   	key = key_scan();
		if(key != 0)
			P0 = ~gsmg_code[key-1]; // 得到的按键值减1换算成数组下标对应0-F段码		
	}		
}
```

## 4. 小结
